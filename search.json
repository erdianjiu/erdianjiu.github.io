[{"title":"爬虫初识","url":"/erdianjiu.github.io/2018/10/05/爬虫初识/"},{"title":"从歌词中提取出单词","url":"/erdianjiu.github.io/2018/10/01/从歌词中提取出单词/","content":"#从单词录音的歌词中提取出单词\n\n```python\nimport os.path\nimport sys\nimport re\n\ndef main_operation(lines): #中文、数字、符号的剔除\n    lis = []\n    ls = []\n    for i in lines:\n        if \".\" not in i[10::] and re.sub('[^A-Za-z]','',i[10::]) and \"(\" not in i:\n            lis.append(i[10::])\n            lis = [word.replace(\"\\n\",\"\")for word in lis]\n    for i in lis:\n        while len(i) < 15:\n            i += \" \"\n        ls.append(i)\n    return ls\n\ndef words_print(lis): #单词的输出格式\n    count = 1\n    for i in range(len(lis)):\n        a = lis[i]\n        if \"Word List\" in a:\n            if count % 5 != 0:\n                print()\n                print(a)\n                count = 1\n        else:\n            print(a+\"   \", end = \"\")\n            count += 1\n        if count % 5 == 0:\n            print()\n\ndef get_lrc(path): #筛选文件，打开并读取内容\n    files = os.listdir(path)\n    ls = []\n    for i in files:\n        if \"lrc\" in i:\n            a = open(\"D:\\\\英语专业四级词汇必背乱序版\\\\熟词生义加核心词汇\\\\\" + i, \"r\")\n            lines = a.readlines()\n            for i in lines:\n                ls.append(i)\n    return ls\n\nif __name__ == \"__main__\":\n    path = \"D:\\\\英语专业四级词汇必背乱序版\\\\熟词生义加核心词汇\"\n    lines = get_lrc(path)\n    lis = main_operation(lines)\n    words_print(lis)\n```\n* 实现了文件夹下的文件筛选，文件内容读取。（改进代码：使用正则表达式实现字符串的全筛选）\n","tags":["python - 字符串处理 - 正则表达式 - 文件打开及读取"]},{"title":"常用数据结构","url":"/erdianjiu.github.io/2018/10/01/常用数据结构/","content":"#数组（Array）\n* Python语言中没有直接提供数组数据类型，通常使用列表作为数组。array模块包含一个array对象，用于实现其他编程语言中的数据结构。通常用矩阵用二维数组来储存，多项式用数组(用两种储存的表示法)和链表来储存。查找数组元素时有公式用来计算！\n\n```python\n#建立一个2*2的空数组arr\nn = 2\narr = [[None] * n for row in range(n)]\n```\nP(x) = 2x**5  + 3x**4 + 5x**2 + 4x + 1用数组来表示。（1）使用一个n+2长度的数组来存放，数组第一个元素用来储存最大指数，然后就是指数从大到小项的系数。优点：程序设计方便，缺点：太浪费内存空间（2）只储存多项式中的非零项。数组的第一个元素用来储存非零项的个数，然后是系数+指数+系数+指数...优点：节约内存空间，缺点：算法设计复杂。\n```python\n#(1)\nA = [5, 2, 3, 0, 5, 4, 1]\n#(2)\nA = [5, 2, 5, 3, 4, 5, 2, 4, 1, 1, 0]\n```\n\n#链表(Linked list)\n* 链表：是由许多相同数据类型的数据项按特定顺序排列而成的线性表。链表的特点是储存位置在计算机中是不连续且随机存放的，其优点是数据插入和删除(内存申请和删除方便)都方便，不需要移动大量数据；缺点是无法像静态数据那样可随机读取数据。\n* 单向链表：\n","tags":["python"]},{"title":"查找算法","url":"/erdianjiu.github.io/2018/09/24/基础查找、排序算法/","content":"#算法的性能分析\n* 算法的性能分析包括两方面：时间复杂度和空间复杂度。\n\n时间复杂度：用big O符号表示。n+1、100n+99属于同增长量级都记为O(n)\n#查找算法\n* 顺序查找：按着顺序从头找到尾。时间复杂度为O(n)。\n\n例:在列表中查找特定数值x：\n\n```python\ndef search(alist, item): #顺序查找法\n    pos = 0              #初始查找位置\n    found = False        #未找到\n    while pos < len(alist) and not found: #列表未结束并且未找到则一直循环\n        if alist[pos] == item: #找到对象，返回True\n            found = True\n        else:\n            pos += 1\n    return found\ndef main(): #测试数据\n    test = [1, 3, 33, 8, 37, 29, 25, 99, 100]\n    print(search(test, 3))\n    print(search(test,98))\nif __name__ == \"__main__\": main()\n```\n\n* 二分查找法：每次从中间项开始查找，若没找到，则判断查找对象大于中间项还是小于中间项，然后继续上个步骤。用于已排好序，或者排序无影响的列表查找。时间复杂度为O(log2N)。\n\n例：在列表中查找特定数值x：\n\n```python\n#非递归实现\ndef search(alist, item): #二分查找法\n    low = 0              #左边界  \n    high = len(alist) - 1    #右边界\n    while low <= high:   #左边界小于右边界，则循环\n        mid = (low + high) // 2  #计算中间位置\n        if alist[mid] < item:\n            low = mid + 1\n        elif alist[mid] > item:\n            high = mid - 1\n        else:\n            return mid   #查找成功返回下标\n    return -1            #不存在查找对象，返回-1\n\ndef main(): #测试数据\n    test = [1, 3, 33, 8, 37, 29, 25, 99, 100]\n    print('索引为',search(test, 3))\n    print('索引为',search(test, 98))\n\nif __name__ == \"__main__\": main()\n```\n```python\n#递归实现\ndef search(item, alist, low, high):  #二分法查找\n    if high <= low: return -1\n    mid = (low + high) // 2\n    if alist[mid] > item:\n        return search(item, alist, low, mid)\n    elif alist[mid] < item:\n        return search(item, alist, mid+1, high)\n    else:\n        return mid\n\ndef binarysearch(item, alist):  #递归二分法查找\n    return search(item, alist, 0, len(alist))\n\ndef main(): #测试数据\n    test = [1, 3, 33, 8, 37, 29, 25, 99, 100]\n    print('索引为',binarysearch(3, test))\n    print('索引为',binarysearch(98, test))\n\nif __name__ == \"__main__\": main()\n```\n\n* 插值查找法（二分查找的改进）：按照数据位置的分布，利用公式预测数据所在的位置，再以二分法的方式渐渐逼近。插值排序的公式：\nMid = low + ((key - data[low]) / (data[high] - data[low])) * (high - low)\n例：随机生成50个数，然后实现插值查找法：\n```python\nimport random\n\ndef interpolation_search(data, val):\n    low  = 0\n    high = 49\n    print('查找过程中...')\n    while low <= high and val != 1:\n        mid = low + int((val - data[low]) * (high - low) / (data[high] - data[low]))\n        if \n\n\n#基础排序算法\n* **loading...**\n","tags":["python"]},{"title":"Mid-Autumn Festival to do list","url":"/erdianjiu.github.io/2018/09/23/Mid-Autumn Festival to do list/","content":"搭建自己的个人网站应该算是完成了大半吧，我将用它来记录自己的算法学习，算是对自己的一直督促、鞭策吧。接下来就是好好学英语，好好学算法！\n\n最后感谢一下@女神小姐姐（没有传送门，嘻嘻嘻）的文章引导。\n"}]